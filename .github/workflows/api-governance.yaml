name: API Governance Engine

# 1. --- Define Inputs ---
on:
  workflow_call:
    inputs:
      swagger_path:
        required: true
        type: string
        description: "Path to the swagger file in the spoke repo (e.g. swagger.yaml)"
      baseline_filename:
        required: true
        type: string
        description: "Name of the baseline file in the Release (e.g. javatest-legacy.yaml)"
      baseline_version:
        required: false
        type: string
        default: 'baselines-v1'
        description: "The Release Tag to download from"

jobs:
  governance-engine:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to download releases
      pull-requests: write
    
    steps:
      # ---------------------------------------------------------
      # 1. Checkout Repositories
      # ---------------------------------------------------------
      - name: Checkout Spoke Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed for history

      - name: Checkout Governance Hub
        uses: actions/checkout@v4
        with:
          repository: KushalBang456/API-Governance-POC
          path: governance-hub

      # ---------------------------------------------------------
      # 2. Setup Environment (MISSING IN YOUR SNIPPET)
      # ---------------------------------------------------------
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      # ---------------------------------------------------------
      # 3. Install Dependencies
      # ---------------------------------------------------------
      - name: Install Dependencies
        run: |
          # Install openapi-diff locally (no -g) for scripting
          npm install openapi-diff
          # Install Spectral globally
          npm install -g @stoplight/spectral-cli
          # Install Python YAML support
          pip install PyYAML

      # ---------------------------------------------------------
      # 4. Prepare Specs (Extract HEAD and TARGET versions)
      # ---------------------------------------------------------
      - name: Prepare Specs
        run: |
          echo "üìç Processing Swagger: ${{ inputs.swagger_path }}"
          
          # A. Capture Filename & Extension
          INPUT_FILE="${{ inputs.swagger_path }}"
          EXT="${INPUT_FILE##*.}"
          
          # B. Determine Target Branch (Dynamic)
          TARGET_BRANCH="${{ github.base_ref }}"
          if [ -z "$TARGET_BRANCH" ]; then
            TARGET_BRANCH="main"
            echo "‚ö†Ô∏è Manual Trigger detected. Defaulting target to 'main'."
          fi

          # 1. Get HEAD version (Current file)
          if [ -f "$INPUT_FILE" ]; then
             cp "$INPUT_FILE" "swagger_head.$EXT"
          else
             echo "‚ùå Error: Swagger file not found at $INPUT_FILE"
             exit 1
          fi
          
          # 2. Get TARGET version (Base Branch)
          echo "Fetching version from origin/$TARGET_BRANCH..."
          git show "origin/$TARGET_BRANCH:$INPUT_FILE" > "swagger_main.$EXT"
          
          echo "‚úÖ Extracted Head and Main specs."

      # ---------------------------------------------------------
      # 5. Download Baseline
      # ---------------------------------------------------------
      - name: ‚¨áÔ∏è Download Baseline from GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching ${{ inputs.baseline_filename }} from tag ${{ inputs.baseline_version }}..."
          gh release download ${{ inputs.baseline_version }} \
            --repo KushalBang456/API-Governance-POC \
            --pattern "${{ inputs.baseline_filename }}"

      # ---------------------------------------------------------
      # 6. Generate Diff (Using NPM Inline Script)
      # ---------------------------------------------------------
      - name: Generate Diff
        run: |
          # 1. Detect extension again
          INPUT="${{ inputs.swagger_path }}"
          EXT="${INPUT##*.}"
          
          echo "üîç Generating diff between swagger_main.$EXT and swagger_head.$EXT..."
          
          # 2. Run inline Node script
          # We use double quotes for the node command so Bash variables ($EXT) expand
          node -e "
            const fs = require('fs');
            const diff = require('openapi-diff');
            
            // Bash variables expand here to actual filenames (e.g., swagger_main.yaml)
            const oldFile = 'swagger_main.$EXT';
            const newFile = 'swagger_head.$EXT';
            
            console.log('Reading files: ' + oldFile + ' and ' + newFile);

            try {
              const oldSpec = fs.readFileSync(oldFile, 'utf8');
              const newSpec = fs.readFileSync(newFile, 'utf8');
              
              diff.diffSpecs({
                sourceSpec: { content: oldSpec, location: 'legacy', format: 'openapi3' },
                destinationSpec: { content: newSpec, location: 'new', format: 'openapi3' }
              }).then(result => {
                fs.writeFileSync('diff.json', JSON.stringify(result, null, 2));
                console.log('‚úÖ diff.json created successfully');
              });
            } catch (err) {
              console.error('‚ùå Error running diff:', err);
              process.exit(1);
            }
          "

      # --- DEBUG STEP: PRINT DIFF ---
      - name: üêû DEBUG - Print Diff.json
        run: |
          echo "=== CONTENT OF DIFF.JSON ==="
          if [ -f "diff.json" ]; then
            cat diff.json
          else
            echo "‚ùå diff.json missing!"
          fi
          echo "============================"

      # ---------------------------------------------------------
      # 7. Run Logic (Python)
      # ---------------------------------------------------------
      - name: Generate Partial Spec
        run: |
          python governance-hub/scripts/generate_partial_spec.py "${{ inputs.baseline_filename }}"

      # --- DEBUG STEP: PRINT PARTIAL SPEC ---
      - name: üêû DEBUG - Print Partial Spec
        run: |
          echo "=== CONTENT OF PARTIAL_SPEC.JSON ==="
          if [ -f "partial_spec.json" ]; then
            cat partial_spec.json
          else
            echo "‚ö†Ô∏è partial_spec.json not found!"
          fi
          echo "===================================="
      
      # ---------------------------------------------------------
      # 8. Linting (Strict) - Save to JSON
      # ---------------------------------------------------------
      - name: üõë Strict Lint (Generate JSON)
        run: |
          # Run spectral and save output to strict.json
          # We use '|| true' because we don't want to crash the build yet.
          # We will handle the failure in the Report step.
          npx spectral lint partial_spec.json \
            --ruleset governance-hub/.spectral.yaml \
            --format json \
            --output strict.json || true

      # ---------------------------------------------------------
      # 9. Linting (Advisory) - Save to JSON
      # ---------------------------------------------------------
      - name: ‚ö†Ô∏è Advisory Lint (Generate JSON)
        run: |
          INPUT="${{ inputs.swagger_path }}"
          EXT="${INPUT##*.}"
          
          # Run spectral and save output to advisory.json
          npx spectral lint "swagger_head.$EXT" \
            --ruleset governance-hub/.spectral-warn.yaml \
            --format json \
            --output advisory.json || true

      # # ---------------------------------------------------------
      # # 10. Generate Beautiful Report & Annotations
      # # ---------------------------------------------------------
      # - name: üìä Generate Governance Report
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const fs = require('fs');

      #       function loadResults(filename) {
      #         if (fs.existsSync(filename)) {
      #           try { return JSON.parse(fs.readFileSync(filename, 'utf8')); } 
      #           catch (e) { return []; }
      #         }
      #         return [];
      #       }

      #       const strictResults = loadResults('strict.json');
      #       const advisoryResults = loadResults('advisory.json');
            
      #       // --- Helper: Clean up the JSON path for display ---
      #       // Converts ["paths", "/admin/health", "get"] -> "paths > /admin/health > get"
      #       function formatPath(pathArray) {
      #         if (!pathArray || pathArray.length === 0) return "root";
      #         return pathArray.join(" > ");
      #       }

      #       // --- Function to Process Results ---
      #       function processResults(results, title, icon, isStrict) {
      #         if (results.length === 0) return `\n### ${icon} ${title}\n\n‚úÖ **No issues found!**\n`;
              
      #         let md = `\n### ${icon} ${title} (${results.length} issues)\n\n`;
              
      #         // Table Header
      #         md += `| Severity | Rule | Location | Message |\n`;
      #         md += `| :---: | :--- | :--- | :--- |\n`;
              
      #         results.forEach(r => {
      #           const isError = r.severity === 0;
      #           const sevIcon = isError ? 'üõë' : '‚ö†Ô∏è';
                
      #           // For Strict (Partial Spec), line numbers are fake/temp, so we hide them.
      #           // For Advisory (Full Spec), line numbers are real, so we keep them.
      #           const lineInfo = isStrict ? "" : `(Line ${r.range.start.line + 1})`;
                
      #           const msg = r.message.replace(/\|/g, '&#124;'); 
      #           const logicalPath = formatPath(r.path);
                
      #           // Build Row: Severity | Rule Code | Location (Clean) | Message + Line Info
      #           md += `| ${sevIcon} | **${r.code}** | \`${logicalPath}\` | ${msg} ${lineInfo} |\n`;

      #           // --- ANNOTATIONS ---
      #           // We still post annotations so they show up in "Files Changed"
      #           const annotationProps = { 
      #             title: `${r.code}`,
      #             file: r.source || 'swagger.yaml', 
      #             startLine: r.range.start.line + 1 
      #           };
                
      #           if (isError) core.error(r.message, annotationProps);
      #           else core.warning(r.message, annotationProps);
      #         });
      #         return md;
      #       }

      #       // --- Generate Content ---
      #       let summary = "# API Governance Report üõ°Ô∏è\n";
      #       summary += "> **Strict Checks:** Run on new/modified code only. (Blocks PR)\n";
      #       summary += "> **Advisory Checks:** Run on the full file. (Tech Debt)\n";
            
      #       // Pass 'true' for strict to hide line numbers, 'false' for advisory to show them
      #       summary += processResults(strictResults, "Strict Checks (New Code)", "üõë", true);
      #       summary += "\n---\n";
      #       summary += processResults(advisoryResults, "Advisory Checks (Tech Debt)", "‚ö†Ô∏è", false);

      #       // --- Post to Job Summary ---
      #       await core.summary.addRaw(summary).write();

      #       // --- Fail Build Logic (Commented out for POC) ---
      #       // const strictErrors = strictResults.filter(r => r.severity === 0).length;
      #       // if (strictErrors > 0) {
      #       //   core.setFailed(`‚ùå Governance Check Failed: ${strictErrors} strict errors found.`);
      #       // }


      # ---------------------------------------------------------
      # 10. Generate Beautiful Report & Manage PR Comments (FIXED)
      # ---------------------------------------------------------
      - name: üìä Generate Report & PR Comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // --- 1. Load Data ---
            function loadResults(filename) {
              if (fs.existsSync(filename)) {
                try { return JSON.parse(fs.readFileSync(filename, 'utf8')); } 
                catch (e) { return []; }
              }
              return [];
            }

            const strictResults = loadResults('strict.json');
            const advisoryResults = loadResults('advisory.json');

            // --- 2. Helper: Generate Summary Table ---
            function formatPath(pathArray) {
              if (!pathArray || pathArray.length === 0) return "root";
              return pathArray.join(" > ");
            }

            function generateSummaryTable(results, title, icon, isStrict) {
              if (results.length === 0) return `\n### ${icon} ${title}\n\n‚úÖ **No issues found!**\n`;
              
              let md = `\n### ${icon} ${title} (${results.length} issues)\n\n`;
              md += `| Severity | Rule | Location | Message |\n`;
              md += `| :---: | :--- | :--- | :--- |\n`;
              
              results.forEach(r => {
                const isError = r.severity === 0;
                const sevIcon = isError ? 'üõë' : '‚ö†Ô∏è';
                const lineInfo = isStrict ? "" : `(Line ${r.range.start.line + 1})`;
                const msg = r.message.replace(/\|/g, '&#124;'); 
                const logicalPath = formatPath(r.path);
                
                md += `| ${sevIcon} | **${r.code}** | \`${logicalPath}\` | ${msg} ${lineInfo} |\n`;

                // Annotations
                const annotationProps = { 
                  title: `${r.code}`,
                  file: r.source || 'swagger.yaml', 
                  startLine: r.range.start.line + 1 
                };
                if (isError) core.error(r.message, annotationProps);
                else core.warning(r.message, annotationProps);
              });
              return md;
            }

            // --- 3. Generate Job Summary (For Actions Tab) ---
            let summary = "# API Governance Report üõ°Ô∏è\n";
            summary += "> **Strict Checks:** Run on new/modified code only. (Blocks PR)\n";
            summary += "> **Advisory Checks:** Run on the full file. (Tech Debt)\n";
            summary += generateSummaryTable(strictResults, "Strict Checks (New Code)", "üõë", true);
            summary += "\n---\n";
            summary += generateSummaryTable(advisoryResults, "Advisory Checks (Tech Debt)", "‚ö†Ô∏è", false);
            
            await core.summary.addRaw(summary).write();


            // --- 4. PR Comment Logic (The Fixed Part) ---
            if (!context.issue.number) {
              console.log("Not a PR, skipping comments.");
              return;
            }

            // A. Define Unique Markers
            const STRICT_MARKER = '';
            const ADVISORY_MARKER = '';

            // B. Fetch All Comments ONCE
            console.log("Fetching existing comments...");
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            // C. Find specific existing comments (if they exist)
            const existingStrictComment = comments.find(c => c.body.includes(STRICT_MARKER));
            const existingAdvisoryComment = comments.find(c => c.body.includes(ADVISORY_MARKER));

            // D. Helper to Create or Update
            async function handleComment(marker, title, results, existingComment) {
              const errors = results.filter(r => r.severity === 0).length;
              const warnings = results.filter(r => r.severity !== 0).length;
              const total = errors + warnings;

              // Build Body
              let body = `${marker}\n### ${title}\n`;
              if (total === 0) {
                body += `‚úÖ **No issues found!**\n\n_Governance check passed._`;
              } else {
                body += `‚ö†Ô∏è **Issues Found**\n`;
                body += `- **Errors:** ${errors}\n`;
                body += `- **Warnings:** ${warnings}\n\n`;
                body += `_Check the [Job Summary](${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details._`;
              }

              if (existingComment) {
                // CASE 1: Comment exists. We MUST update it (to either show new errors or show "Fixed").
                console.log(`Updating existing comment for: ${title}`);
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: body
                });
              } else {
                // CASE 2: Comment does not exist.
                // We only create it if there are actual issues (total > 0).
                // If total is 0 and no comment exists, we stay silent.
                if (total > 0) {
                  console.log(`Creating new comment for: ${title}`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: body
                  });
                } else {
                  console.log(`No issues for ${title} and no previous comment. Staying silent.`);
                }
              }
            }

            // E. Execute Handlers Independently
            await handleComment(STRICT_MARKER, "üõë API Governance: Strict Checks", strictResults, existingStrictComment);
            await handleComment(ADVISORY_MARKER, "‚ö†Ô∏è API Governance: Advisory Checks", advisoryResults, existingAdvisoryComment);